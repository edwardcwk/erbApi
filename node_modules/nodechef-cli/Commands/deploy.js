var cli = require('../cli'), 
    fs = require('fs'),
    endpoints = require('../endpoints'),
    minjs = require('uglify-js'),
    archiver = require('archiver'),
    mincss = require('uglifycss'),
    remote = require('../remotecommon')
    request = require('request'),
    path = require('path'), 
    status = require('../deploymentstatus'), 
    app_status = require('./status'),
    spin = require('../Spinner')(''),
    spawn = require('child_process').spawn;

var NC_MANIFEST_FILE = 'ncmanifest.json',
    NC_IGNORE = '.ncignore',
    NC_CLOUD_ENV = null,
    NC_REMOTE_DELETIONS_FILENAME = '__ncremote_delete__', 
    NC_BUNDLE_FILENAME = '__ncbundle__.zip', 
    NC_ASSET_STATE_MODIFIED = 2,
    NC_ASSET_UNCHANGED = 3,        
    NC_ASSET_STATE_NEW = 1,
    WIN_32 = /^win/.test(process.platform);

function recursivelyAddToArchive(base_dir, p_array, tracker, is_base_dir, ignore_set, include_dir) {

    var key_prefix = p_array.join('/');
    var files = fs.readdirSync(base_dir);

    if (files.length == 0) {
        // empty directory..
        tracker[key_prefix] = { mt: mt, exists: true, is_dir : true, state: NC_ASSET_STATE_NEW, path: base_dir };
        return; 
    }

    for (var i = 0, ii = p_array.length; i < files.length; i++) {
        if (files[i] == NC_BUNDLE_FILENAME) continue;

        if (ignore_set && ignore_set.hasOwnProperty(files[i]))
            continue;

        if (is_base_dir) {
            if (include_dir && !include_dir.hasOwnProperty(files[i]))
                continue;
        }

        var fs_asset = path.join(base_dir, files[i]);

        if (fs.lstatSync(fs_asset).isSymbolicLink()) {
            fs_asset = fs.realpathSync(fs_asset);
        }

        if (fs.lstatSync(fs_asset).isDirectory()) {
            p_array.push(files[i]);
            recursivelyAddToArchive(fs_asset, p_array, tracker, false);
            p_array.splice(ii, 1);
        }
        else {
            var key = key_prefix != "" ? key_prefix + '/' + files[i] : files[i];
            var stat = fs.statSync(fs_asset);
            var mt = stat.mtime.toString();

            if (tracker.hasOwnProperty(key)) {

                var last_modified_tracked = tracker[key];
                last_modified_tracked.exists = true;;

                if (last_modified_tracked.mt != mt) {
                    last_modified_tracked.mt = mt;
                    last_modified_tracked.state = NC_ASSET_STATE_MODIFIED;
                    tracker[key] = last_modified_tracked;
                }
            }
            else {
                tracker[key] = { mt: mt, exists: true, state: NC_ASSET_STATE_NEW, path: fs_asset };
            }
        }
    }
}

function GetAbsolutePath(binary_path, bin_path) {
    if (bin_path != null) {
        if (!((bin_path.length > 1 && bin_path.charAt(0) == '/') || (bin_path.length > 2 && bin_path.charAt(1) == ':'))) {
            bin_path = path.join(binary_path, bin_path);
        }

        return bin_path;
    }
    else {
        return binary_path;
    }
}

function GetFolderDiff(application_name, binary_path, asset_prefix, reset_tracking, include_dir, remote_delete, changes, disable_id) {
    var obj = {}; 
    if (!(disable_id != undefined && disable_id)) {
        var changes_track_file = path.join(binary_path, asset_prefix + application_name + '.json');
        if (!reset_tracking) {
            obj = cli.ObjectFromFile(changes_track_file);
            if (obj == null) {
                obj = {};
                cli.debug('Parse asset tracking file returned null');
            }
            else {
                cli.debug('Tracking assets: ' + JSON.stringify(obj));
                for (var s in obj) {
                    var o = obj[s];
                    o.exists = false;
                    o.state = NC_ASSET_UNCHANGED;
                }
            }
        }
        else
           cli.debug('Forced asset tracking reset'); 
    }
    
    var ignore_file = path.join(binary_path, NC_IGNORE),
        ignore_set = {
            '.git': 1,
            '.ncignore': 1,
            'node_modules': 1,
            '__ncbundle__.zip': 1,
        };

    ignore_set[(asset_prefix + application_name + '.json')] = 1; 

    if (fs.existsSync(ignore_file)) {
        var ignore_file = fs.readFileSync(ignore_file, { encoding: 'utf8' });
        ignore_file = ignore_file.trim();

        var set = ignore_file.split("\n");
        for (var i = 0 ; i < set.length; i++) {
            var v = set[i].trim();
            if (v.length > 0 && !ignore_set.hasOwnProperty(v)) {
                if (v.charAt(v.length - 1) == '\r') {
                    v = v.substring(0, v.length - 1);
                }

                ignore_set[v] = 1;
            }
        }
    }

    for (var s in ignore_set)
        cli.writeline('Ignore file or directory with name: ' + cli.writevariable(s));

    recursivelyAddToArchive(binary_path, [], obj, true, ignore_set, include_dir);

    var has_changes = false;

    for (var s in obj) {
        var o = obj[s];
        if (s == NC_REMOTE_DELETIONS_FILENAME) {
            cli.writeerror('Cannot name file using reserved name ' + cli.writevariable(NC_REMOTE_DELETIONS_FILENAME));
            return;
        }

        if (!o.exists) {
            if (o.is_dir)
                cli.writeline('Remote delete directory: ' + cli.writevariable(s));
            else
                cli.writeline('Remote must delete file: ' + cli.writevariable(s));

            remote_delete.push(s);
            has_changes = true;
        }
        else {
            if (o.state == NC_ASSET_STATE_NEW) {
                has_changes = true;

                if (o.is_dir)
                    cli.writeline('Remote accept new directory ' + cli.writevariable(s));
                else
                    cli.writeline('Remote accept new file: ' + cli.writevariable(s));

                changes[s] = o;
            }
            else if (o.state == NC_ASSET_STATE_MODIFIED) {
                has_changes = true;
                changes[s] = o;
                cli.writeline('Remote overwrite existing file: ' + cli.writevariable(s));
            }
        }
    }

    if (!has_changes) {
        cli.writeline('Nothing has changed since you last deployed');
        process.exit(1);
    }

    for (var i = 0; i < remote_delete.length; i++) {
        delete obj[remote_delete[i]]; 
    }

    return obj;
}

var update_changes_tracking_content = null,
    changes_tracking_path = null; 

function BundleAssets(application_name, binary_path, asset_prefix,  reset_tracking, remote_del_file_name, include_dir, cb, on_asset_add_to_archive, disable_id) {
    var remote_delete = [], changes = {};
    var obj = GetFolderDiff(application_name, binary_path, asset_prefix, reset_tracking, include_dir, remote_delete, changes, true); 
    var bundle_path = path.join(binary_path, NC_BUNDLE_FILENAME);
    if (fs.existsSync(bundle_path))
        fs.unlinkSync(bundle_path);

    var output = fs.createWriteStream(bundle_path);
    var archive = archiver('zip', {
        zlib: { level: 9 }
    });

    output.on('close', function () {
        spin.stop();
        cli.writeline('Length of zip archive in bytes: [' + archive.pointer() + ']');
        var changes_track_file = path.join(binary_path, asset_prefix + application_name + '.json');
        cb(bundle_path, fs.existsSync(changes_track_file));

        if (!(disable_id != undefined && disable_id)) {
            changes_tracking_path = changes_track_file;
            update_changes_tracking_content = JSON.stringify(obj, null, 2);             
        }
    });

    output.on('end', function () { });

    archive.on('warning', function (err) {
        if (err.code != 'ENOENT') {
            cli.writeerror(err.toString())
            fs.fs.unlinkSync(bundle_path);
            process.exit(1);
        }
    });

    archive.on('error', function (err) {
        cli.writeerror(err.toString())
        fs.fs.unlinkSync(bundle_path);
        process.exit(1);
    });

    archive.pipe(output);

    spin.text = 'Creating zip archive...      ';
    spin.start();

    function AddToArchive(s, is_dir) {
        try {
            if (is_dir) {
                spin.text = 'Add directory: ' + s;
                archive.append(null, { name: s + '/' });
            }
            else {
                spin.text = 'Add file: ' + s;
                archive.append(fs.createReadStream(changes[s].path), { name: s });
            }
        }
        catch (e) {
            cli.writeerror('Cannot add resource to archive - Error: ' + e);
            cli.writeerror(changes[s].path);
            process.exit(1); 
        }
    }

    if (on_asset_add_to_archive) {
        for (var s in changes) {
            if (!on_asset_add_to_archive(s, changes[s].path, archive)) {
                AddToArchive(s); 
            }
        }
    }
    else {
        for (var s in changes) {
            AddToArchive(s, changes[s].is_dir); 
        }
    }

    if (remote_delete.length > 0)
        archive.append(JSON.stringify(remote_delete), { name: remote_del_file_name });

    archive.finalize();
}

function DeployBundle(request_path, app_name, formData, meta_data, id, unlink, on_cmp) {
    cli.debug(JSON.stringify(formData)); 
    cli.writeline('Binary info: ' + JSON.stringify(meta_data, null, 2));
    cli.writeline('Lift off!');
    console.log(''); 

    request.post({
        url: request_path,
        headers: remote.getRequestHeaders(),
        formData: formData,
    }, function (err, res, body) {
        if (err) {
            cli.writeerror(err);
        }
    });

    var prog = new status(id, app_name, NC_CLOUD_ENV, function (s) {

        if (changes_tracking_path != null) {
            cli.writeline('Commit changes to asset tracking file: [' + changes_tracking_path + ']');
            fs.writeFileSync(changes_tracking_path, update_changes_tracking_content);
        }

        if (on_cmp) on_cmp();
    });
    prog.startPolling();
}

function UploadStatics(application_name, bin_path, rebuild, unlink) {
    var id = cli.randomId();
    var request_path = endpoints.staticsdeploy(NC_CLOUD_ENV);
    var meta_data = {
        id: id,
        app: application_name
    };

    if (rebuild)
        meta_data['rebuild'] = '1'; 

    DeployBundle(request_path, application_name, {
        deploypackage: JSON.stringify(meta_data),
        filestream: {
            value: fs.createReadStream(bin_path),
            options: {
                filename: NC_BUNDLE_FILENAME,
                contentType: 'application/zip' 
            }
        }
    }, meta_data, id, true, function () {
        if (unlink)
            fs.unlinkSync(bin_path);

        cli.writeline('Static assets deployment completed'); 
    });
}

function DeployStatics(application_name, bin_path, minify_assets, reset_tracking) {
    if (!fs.lstatSync(bin_path).isDirectory()) {
        UploadStatics(application_name, bin_path, reset_tracking, false);
    }
    else if (minify_assets) {
        BundleAssets(application_name, bin_path, '__nc_statics__', reset_tracking, '__nodechef_statics_deleted__.json', undefined, function (bin_path) {
            UploadStatics(application_name, bin_path, reset_tracking, true);
        }, function (name, fn, archive) {
            if (name.endsWith('.js') && !name.endsWith('.min.js')) {
                cli.writeline('Minify js asset: [' + name + ']');
                var code = fs.readFileSync(fn, { encoding: 'utf8' });
                var options = { warnings: true };
                var result = minjs.minify(code, options);
                if (result.error) {
                    cli.writeerror(result.error);
                    process.exit(1); 
                }
                cli.debug(result.warnings);
                archive.append(result.code, { name: name });
                return true; 
            }
            else if (name.endsWith('.css') && !name.endsWith('.min.css')) {
                cli.writeline('Minify css asset: [' + name + ']');
                var code = fs.readFileSync(fn, { encoding: 'utf8' });
                var options = { maxLineLen: 500, expandVars: true };
                var minified = mincss.processString(code, options);
                archive.append(minified, { name: name }); 
                return true; 
            }
            return false;
        });
    }
    else {
        BundleAssets(application_name, bin_path, '__nc_statics__', reset_tracking, '__nodechef_cloudcode_deleted__.json', undefined, function (bin_path) {
            UploadStatics(application_name, bin_path, reset_tracking, true); 
        }); 
    }
}

function UploadParseServerCloudCode(application_name, reset_tracking, bin_path, unlink) {
    var id = cli.randomId();
    var request_path = endpoints.cloudcodedeploy(NC_CLOUD_ENV);
    var meta_data = {
        id: id,
        app: application_name,
    };

    if (reset_tracking)
        meta_data['rebuild'] = '1';

    DeployBundle(request_path, application_name, {
        deploypackage: JSON.stringify(meta_data),
        filestream: {
            value: fs.createReadStream(bin_path),
            options: {
                filename: NC_BUNDLE_FILENAME,
                contentType: 'application/zip'
            }
        }
    }, meta_data, id, true, function () {

        if (unlink)
            fs.unlinkSync(bin_path);

        cli.writeline('Parse Server cloud code deployed successfully - Check container(s) status with the command [nc status -i ' + application_name + ']');
    });
}

function DeployCloudCode(application_name, bin_path, is_cloud_code_with_statics, reset_tracking) {
    if (fs.lstatSync(bin_path).isDirectory()) {
        var include_dir = { 'cloud': 1 };
        if (is_cloud_code_with_statics)
            include_dir['public'] = 1;

        if (!fs.existsSync(path.join(bin_path, 'cloud'))) {
            cli.writeerror('The [cloud] folder does not exist in the directory [' + bin_path + ']');
            process.exit(1);
        }

        var package_json = path.join(bin_path, 'cloud', 'package.json');
        if (!fs.existsSync(package_json)) {
            // attempt to generate a package.json for the node_modules..
            var node_modules = path.join(bin_path, 'cloud', 'node_modules');
            if (fs.existsSync(node_modules)) {
                var files = fs.readdirSync(node_modules), dependencies = {}, has_module = false;
                for (var i = 0; i < files.length; i++) {
                    var module_package_json = path.join(node_modules, files[i], 'package.json');
                    if (fs.existsSync(module_package_json)) {
                        try {
                            var obj = JSON.parse(fs.readFileSync(module_package_json));
                            if (obj.hasOwnProperty('version')) {
                                dependencies[files[i]] = obj.version;
                                has_module = true;
                            }
                        }
                        catch (e) {
                            cli.debug('Cannot parse package.json file for module: [' + files[i] + '] - Error: ' + e);
                        }
                    }
                }

                if (has_module) {
                    var pk_json = {
                        name: application_name,
                        description: 'NodeChef auto generated package.json for parse server cloud code',
                        version: global.__NC_VER,
                        main: 'main.js',
                        dependencies: dependencies
                    }

                    fs.writeFileSync(package_json, JSON.stringify(pk_json, null, 2));
                }
            }
        }

        BundleAssets(application_name, bin_path, '__nc_ccode__', reset_tracking, '__nodechef_cloudcode_deleted__.json', include_dir, function (bin_path) {
            UploadParseServerCloudCode(application_name, reset_tracking, bin_path, true); 
        });
    }
    else {
        UploadParseServerCloudCode(application_name, reset_tracking, bin_path, false); 
    }
}

function hasAssetEndingWith(bin_path, asset) {
    var files = fs.readdirSync(bin_path);
    asset = asset.substring(1);
    for (var i = 0; i < files.length; i++) {
        if (files[i].endsWith(asset)) {
            cli.debug('Match: [' + files[i] + '] endsWith: [' + asset + ']');
            return true;
        }
    }
    return false;
}

function DetectApplicationType(bin_path) {
    // only detect and use one buildpack for now..
    var lang_assets = {
        PHP: ['index.php', 'composer.json'],
        Elixir: ['mix.exs'],
        Ruby: ['Gemfile'],
        Go: ['glide.yaml', 'Gopkg.toml', 'Gopkg.lock', 'Godeps/Godeps.json', 'vendor/vendor.json', 'src|*.go', 'vendor|*.go'],
        Dotnet: ['*.runtimeconfig.json', '*.csproj', '*.fsproj', '*.fsproj'],
        Python: ['requirements.txt', 'setup.py', 'environment.yml', 'Pipfile'],
        Meteor: ['.meteor/release'],
        Nodejs: ['package.json'],
        'https://github.com/heroku/heroku-buildpack-java.git': ["pom.xml", "pom.atom", "pom.clj", "pom.groovy", "pom.rb", "pom.scala", "pom.yaml", "pom.yml"],
        'https://github.com/heroku/heroku-buildpack-gradle.git': ["gradlew", "build.gradle", "settings.gradle"],
        'https://github.com/heroku/heroku-buildpack-scala.git': ["project/build.properties;*.sbt", "project/build.properties;*.scala"],
        dockerfile: ['Dockerfile']
    };

    for (var s in lang_assets) {
        var set = lang_assets[s];
        var i = 0;
        for (; i < set.length; i++) {
            var val = set[i];
            if (val.indexOf(';') > -1) {
                var parts = val.split(';');
                var x = 0;
                for (; x < parts.length; x++) {
                    var p = parts[x];
                    if (p.charAt(0) == '*') {
                        if (!hasAssetEndingWith(bin_path, p))
                            break; 
                    }
                    else {
                        var langr = path.join(bin_path, p);
                        if (!fs.existsSync(langr))
                            break;
                    }
                }
                if (x == parts.length) {
                    return [s];
                }
            }
            else if (val.charAt(0) == '*') {
                if (hasAssetEndingWith(bin_path, val))
                    return [s];
            }
            else if (val.indexOf('|') > -1) {
                var _path = val.split('|'), langr = bin_path;
                var x = 0, len = _path.length - 1;

                for (; x < len; x++)
                    langr = path.join(langr, _path[x]);

                if (fs.existsSync(langr)) {
                    if (_path[x].charAt(0) == '*') {
                        if (hasAssetEndingWith(langr, _path[x]))
                            return [s];
                    }
                    else {
                        langr = path.join(langr, _path[x]);
                        if (fs.existsSync(langr))
                            return [s];
                    }
                }
            }
            else {
                var langr = path.join(bin_path, val);
                if (fs.existsSync(langr)) {
                    return [s];
                }
            }
        }
    }
}

function MeteorBuild(binary_path, meteorBuild, cb) {
    var buildOptions = meteorBuild;
    var args = [];

    var executable = buildOptions.executable || 'meteor';

    if (!buildOptions.disableSuperuser)
        args.push('--allow-superuser');

    args.push('build');

    var output_bin_path = binary_path;

    if (buildOptions.buildLocation)
        output_bin_path = buildOptions.buildLocation;

    var build_file_name = path.basename(binary_path) + '.tar.gz';

    var build_output = path.join(output_bin_path, build_file_name);
    args.push(output_bin_path);

    if (fs.existsSync(build_output))
        fs.unlinkSync(build_output);

    args.push('--architecture');
    args.push('os.linux.x86_64');

    if (buildOptions.mobileSettings) {
        args.push('--mobile-settings');
        args.push(JSON.stringify(buildOptions.mobileSettings));
    }

    if (buildOptions.serverOnly) {
        args.push('--server-only');
    } else if (!buildOptions.mobileSettings) {
        args.push('--mobile-settings');
        args.push(path.join(binary_path, 'settings.json'));
    }

    if (buildOptions.server) {
        args.push('--server');
        args.push(buildOptions.server);
    }

    if (buildOptions.allowIncompatibleUpdate) {
        args.push('--allow-incompatible-update');
    }

    if (WIN_32) {
        // Sometimes cmd.exe not available in the path
        // See: http://goo.gl/ADmzoD
        executable = process.env.comspec || 'cmd.exe';
        args = ['/c', 'meteor'].concat(args);
    }

    var env = process.env;
    env['METEOR_HEADLESS'] = 1;
    var options = {
        cwd: binary_path,
        env: env,
        stdio: 'inherit'
    };

    cli.writeline('Build command: ' + executable + ' ' + args.join(" "));

    var meteor = spawn(executable, args, options);

    meteor.on('error', e => {
        cli.writeerror(options);
        cli.writeerror(e);
        cli.writeerror('This error usually happens when meteor is not installed.');
    });
    meteor.on('close', function () {

        if (!fs.existsSync(build_output)) {
            cli.writeerror('Cannot find the build ouput of your meteor application: ' + cli.writevariable(build_file_name) + ' in the build location: ' + output_bin_path);
            return;
        }

        cb(build_output);
    });
}

function DispatchBundleToNCBridge(application_name, bin_path, build_packs, env_vars, start_cmd, st_wait, update_after_ping, unlink, is_continuous, rebuild, dockerfile_relative_path) {

    var id = cli.randomId();
    var request_path = endpoints.deploy(NC_CLOUD_ENV);

    var meta_data = {
        buildpacks: build_packs,
        source: global.__NC_CLI
    }

    if (update_after_ping)
        meta_data['updateafterping'] = '1';

    if (start_cmd)
        meta_data['startcmd'] = start_cmd;

    if (st_wait > 0)
        meta_data['wait'] = st_wait;

    meta_data['id'] = id;
    meta_data['app'] = application_name;

    if (dockerfile_relative_path) {
        meta_data['dockerfile_relative_path'] = dockerfile_relative_path;
    }

    /*
    if (is_continuous) {
        meta_data['incremental'] = '1';
        if (rebuild)
            meta_data['rebuild'] = '1';
    }
    **/

    var form_data = null; 

    if (NC_CLOUD_ENV == endpoints.envBM) {
        var env_str = '';
        if (env_vars && Object.keys(env_vars).length > 0)
            env_str = JSON.stringify(env_vars);

        form_data = {
            deploypackage: JSON.stringify(meta_data),
            meteorsettings: '',
            envvars: env_str,
            filestream: {
                value: fs.createReadStream(bin_path),
                options: {
                    filename: NC_BUNDLE_FILENAME,
                    contentType: 'application/zip'
                }
            }
        }
    }
    else {
        form_data = {
            deployinfo: JSON.stringify(meta_data),
            deploycode: {
                value: fs.createReadStream(bin_path),
                options: {
                    filename: NC_BUNDLE_FILENAME,
                    contentType: 'application/zip'
                }
            }
        }
    }

    DeployBundle(request_path, application_name, form_data,
    meta_data, id, unlink, function () {
        if (unlink)
            fs.unlinkSync(bin_path);

        cli.writeline('Application deployed successfully - Check container(s) status with the command [nc status -i ' + application_name + ']');
    });
}

function DeployApp(application_name, bin_path, env_vars, bp, start_cmd, st_wait, update_after_ping, meteor_build, reset_tracking, dockerfile_relative_path) {
    var bin_is_dir = fs.lstatSync(bin_path).isDirectory();

    if (bp == null || bp.length == 0) {
        if (bin_path.endsWith('.jar') || bin_path.endsWith('.war'))
            bp = ['java'];
        else if (bin_is_dir) {
            bp = DetectApplicationType(bin_path);
            if (bp && bp.length > 0) {
                for (var i = 0; i < bp.length; i++) {
                    cli.writeline(bp[i] + ' Application detected');
                    bp[i] = bp[0].toLocaleLowerCase();
                }
            }
        }
        else if ((bin_path.endsWith('.tar.gz') || bin_path.endsWith('.tgz'))) {
            /** This is the default behaviour previously when NodeChef only supported Meteor.js applications. .tar.gz and .tgz is considered as Meteor.js */
            bp = ['meteor'];
        }

        if (!bp || bp == null || bp.length == 0) {
            cli.writeerror('Failed to identify a suitable buildpack for your application. You can provide this information using the [-bp] option'); 
            process.exit(1); 
        }
    }

    if (bp[0] == 'meteor') {

        if (bin_is_dir) {
            if (Object.keys(meteor_build).length == 0) {
                cli.writeline('Building meteor with default options - You could provide build parameters using the meteorbuild attribute in the [' + NC_MANIFEST_FILE + '] file');
            }

            MeteorBuild(bin_path, meteor_build, function (b) {
                DispatchBundleToNCBridge(application_name, b, bp, env_vars, start_cmd, st_wait, update_after_ping, true, false, true);
            })
        }
        else {
            DispatchBundleToNCBridge(application_name, bin_path, bp, env_vars, start_cmd, st_wait, update_after_ping, false, false, true); 
        }

        return; 
    }
    else if (!bin_is_dir) {
        DispatchBundleToNCBridge(application_name, bin_path, bp, env_vars, start_cmd, st_wait, update_after_ping, false, false, true);
        return; 
    }

    var cnt_deploy = bp.length == 1 && bp[0] == 'nodejs';

    BundleAssets(application_name, bin_path, '__nc_app__', reset_tracking, NC_REMOTE_DELETIONS_FILENAME, undefined, function (bundle_path, is_cnt_deploy) {
        if (cnt_deploy) cnt_deploy = is_cnt_deploy;
        DispatchBundleToNCBridge(application_name, bundle_path, bp, env_vars, start_cmd, st_wait, update_after_ping, true, cnt_deploy, reset_tracking, dockerfile_relative_path);
    }, null, !cnt_deploy);
}

function DeployHelp() {
    var str = [];
    str.push(cli.colors.BRIGHT_CYAN); 
    str.push('Usage:   nc deploy [OPTIONS]');
    str.push(cli.colors.RESET); 
    str.push('\n\n');
    str.push(cli.colors.BRIGHT_CYAN); 
    str.push('Options:\n');
    str.push(cli.colors.RESET); 
    str.push('  -i               Specify the name of your application\n');
    str.push('  -bp              Specify application buildpack(s). Separate multiple values with a comma\n');
    str.push('  -buildpack       Specify application buildpack(s). Separate multiple values with a comma\n');
    str.push('  -ev              Specify an environment variable. Example -ev "NAME=VALUE" \n');
    str.push('  -l               Specify the relative or absolute path to your applicaiton build\n');
    str.push('  -mp              Specify the relative or absolute path to the NodeChef manifest file if applicable\n');
    str.push('  -e               Specify the relative or absolute path to the file containing\n');
    str.push('                   JSON formatted environment variables\n');
    str.push('  -meteorsettings  Specify the relative or absolute path the your Meteor.js\n');
    str.push('                   settings file. \n');
    str.push('  --statics        Deploy static assets to the load balancer\n');
    str.push('  --minify         Minify .css and .js files when deploying static assets\n');
    str.push('  --ccode          Deploy Parse server cloud code\n');
    str.push('  --includestatics Deploy Cloud code together with your public folder\n');
    str.push('  --rebuild        Reset file tracking information for this application and redeploy all files\n');
    str.push('                   Valid for only static assets, cloud code and Node.js deployments. \n');
    str.push('  --rs             Alias for the --rebuild option\n');
    str.push('  --startupwait    The number of seconds to wait before committing this new build and then\n')
    str.push('                   remove the old version of your app running\n');
    str.push('  --updateafterping  When specified, the new build will only be committed after a successful ping\n');
    str.push('                     has been made to the new container\n');
    str.push('\n')
    str.push(cli.colors.BRIGHT_CYAN);
    str.push('Examples:\n');
    str.push(cli.colors.RESET);
    str.push(cli.colors.BRIGHT_MAGENTA);
    str.push('* [Deploy your Node.js, Meteor.js, Ruby, PHP, Python, JVM, Golang, .Net Core, Elixir apps]\n')
    str.push(cli.colors.RESET);
    str.push('  nc deploy -i hello-world-app\n');
    str.push('  nc deploy -i hello-world-app -e myenvfile.txt\n');
    str.push('  nc deploy -i hello-world-app -meteorsettings settings.json\n');
    str.push('  nc deploy -i hello-world-app -bp elixir,phoenix-static\n');
    str.push('  nc deploy -i go-app -bp https://github.com/cloudfoundry/go-buildpack.git\n');
    str.push('  nc deploy -i hello-world-app -bp java -ev "ROOT_URL=http://example.com" -ev "VAR=VAR_VALUE"\n');
    str.push('\n');
    str.push(cli.colors.BRIGHT_MAGENTA);
    str.push('* [Deploy your Parse Server cloud code]\n')
    str.push(cli.colors.RESET);
    str.push('  nc deploy -i my-parse-app --ccode\n');
    str.push('\n')
    str.push(cli.colors.BRIGHT_MAGENTA);
    str.push('* [Deploy your static assets to the Load balancer directly]\n'); 
    str.push(cli.colors.RESET);
    str.push('  nc deploy -i hello-world-app --statics\n');
    str.push('  nc deploy -i hello-world-app --statics --minify\n');
    console.log(str.join(""));
}

function HandleRequest(args) {
    if (args && args.length > 0 && args[0] == 'help') {
        if (args.length > 1) {
            cli.writeerror('No supported arguments available for the help option');
            return; 
        }

        DeployHelp();
        return; 
    }

    var cdir = process.cwd(), binary_path = cdir, bin_path = null, manifest_path = null, application_name = null, environment_file = null, reset_tracking = false,
        cmd = null, use_bp = null, cli_env_vars = {}, var_dc = null, ruas = 0, update_after_ping = false, meteor_settings_file = null, is_statics_deploy = false, is_cloud_code_deploy = false, 
        minify_static_assets = false, is_cloud_code_with_statics = false, meteor_build = null, auth_token = null, dockerfile_relative_path = null;

    if (args && args.length > 0) {
        for (var i = 0, v; i < args.length; ++i) {
            switch (args[i]) {
                case '-l':
                    bin_path = cli.nextArg(args, i).trim(); ++i;
                    break;
                case '-i':
                    application_name = cli.nextArg(args, i); ++i;
                    break;
                case '-e':
                    environment_file = cli.nextArg(args, i); ++i;
                    break;
                case '-mp':
                    manifest_path = cli.nextArg(args, i); ++i;
                    break; 
                case '-ev':
                    {
                        var_dc = cli.nextArg(args, i); ++i;
                        var x = var_dc.indexOf('=');
                        if (x == -1) {
                            cli.writeline('Invalid environment variable declaration: [' + var_dc + ']');
                            return;
                        }
                        cli_env_vars[var_dc.substring(0, x)] = var_dc.substring(++x);
                    }
                    break;
                case '-bp':
                    use_bp = cli.nextArg(args, i); ++i;
                    break;
                case '-buildpack':
                    use_bp = cli.nextArg(args, i); ++i;
                    break;
                case '-dfdir':
                    dockerfile_relative_path = cli.nextArg(args, i); ++i;
                    break;
                case '-auth':
                    auth_token = cli.nextArg(args, i); ++i;
                    break;
                case '-meteorsettings':
                    meteor_settings_file = cli.nextArg(args, i); ++i;
                    break;
                case '--startupwait':
                    ruas = cli.nextIntArg(args, i); ++i;
                    break;
                case '--updateafterping':
                    update_after_ping = true;
                    break;
                case '--rs':
                    reset_tracking = true;
                    break;
                case '--rebuild':
                    reset_tracking = true;
                    break;
                case '-cmd':
                    cmd = cli.nextArg(args, i); ++i;
                    break;
                case '--statics':
                    is_statics_deploy = true;
                    break;
                case '--minify':
                    minify_static_assets = true;
                    break;
                case '--ccode':
                    is_cloud_code_deploy = true;
                    break;
                case '--includestatics':
                    is_cloud_code_with_statics = true;
                    break;
                default:
                    cli.errors.unknownSwitch(args[i], 'deploy');
                    process.exit(1);
                    return;
            }
        }
    }

    if (null != auth_token) {
        global['__NC_API_TOKEN'] = auth_token;
		cli.debug('Using deployment token: ' + auth_token); 
    }
    else if (!cli.isAuthenticated())
        return;

    // check if ncmanifest.json file exist in the current working directory..
    bin_path = GetAbsolutePath(binary_path, bin_path);

    if (use_bp != null)
        use_bp = use_bp.split(',');

    var manifest = null;

    if (manifest_path != null)
        manifest = GetAbsolutePath(binary_path, manifest_path);
    else if (fs.lstatSync(bin_path).isDirectory()) 
        manifest = path.join(bin_path, NC_MANIFEST_FILE);

    if (manifest != null && fs.existsSync(manifest)) {
        var obj = cli.ObjectFromFile(manifest);
        if (obj == null) process.exit(1);

        if (obj.hasOwnProperty('name'))
            application_name = obj.name;

        if (obj.env) {
            for (var s in obj.env) {
                cli_env_vars[s] = obj.env[s];
            }
        }

        if (use_bp == null && obj.buildpacks && obj.buildpacks.length > 0) {
            use_bp = obj.buildpacks;
        }

        if (ruas == 0 && obj.startupwait)
            ruas = obj.startupwait;

        if (obj.updateafterping)
            update_after_ping = obj.updateafterping;

        meteor_build = obj.meteorbuild;
    }
    else if (manifest_path != null) {
        cli.writeerror('The specified path [' + manifest_path + '] to the NodeChef manifest file does not exist');
        process.exit(1); 
    }

    if (application_name == null)
        application_name = path.basename(bin_path);

    if (application_name == null) {
        cli.writeerror('Could not resolve the application name to proceed with request - Consider using the [-i] option to specify the application name'); 
        process.exit(1); 
    }

    // get a route to deploy to..
    remote.GetBridgeRoute(application_name, function (cloud_env) {
        NC_CLOUD_ENV = cloud_env;
        cli.debug('Application environment: ' + cloud_env); 
        if (is_statics_deploy) {
            DeployStatics(application_name, bin_path, minify_static_assets, reset_tracking);
        }
        else if (is_cloud_code_deploy) {
            DeployCloudCode(application_name, bin_path, is_cloud_code_with_statics, reset_tracking);
        }
        else {
            if (environment_file != null) {
                environment_file = GetAbsolutePath(binary_path, environment_file);

                if (!fs.existsSync(environment_file)) {
                    cli.writeerror('The specified file: [' + environment_file + '] to contain your environment variables does not exist');
                    process.exit(1);
                }

                var env_obj = cli.ObjectFromFile(environment_file);
                if (env_obj == null) process.exit(1);

                for (var s in env_obj)
                    cli_env_vars[s] = env_obj[s];
            }

            if (meteor_settings_file != null) {
                meteor_settings_file = GetAbsolutePath(binary_path, meteor_settings_file);

                if (!fs.existsSync(meteor_settings_file)) {
                    cli.writeerror('The specified file: [' + meteor_settings_file + '] to contain your meteor settings does not exist');
                    process.exit(1);
                }

                var m_obj = cli.ObjectFromFile(meteor_settings_file);
                if (m_obj == null) process.exit(1);

                cli_env_vars['METEOR_SETTINGS'] = JSON.stringify(m_obj);
            }

            if (!meteor_build) {
                meteor_build = {};
            }

            DeployApp(application_name, bin_path, cli_env_vars, use_bp, cmd, ruas, update_after_ping, meteor_build, reset_tracking, dockerfile_relative_path);
        }
    });
}

module.exports = HandleRequest;